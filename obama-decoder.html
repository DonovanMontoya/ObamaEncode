<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Obama Decoder - Tested</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.1.0/pako.min.js"></script>
    <style>
        body { font-family: Arial, sans-serif; max-width: 800px; margin: 50px auto; padding: 20px; background: #f5f5f5; }
        .container { background: white; padding: 30px; border-radius: 10px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); }
        input, button { display: block; margin: 15px 0; padding: 12px; width: calc(100% - 28px); }
        button { background: #2196F3; color: white; cursor: pointer; border: none; border-radius: 5px; }
        .status { margin: 20px 0; padding: 15px; border-radius: 5px; }
        canvas { display: none; }
        #result { display: none; background: #e8f5e9; padding: 20px; border-radius: 10px; margin: 20px 0; }
    </style>
</head>
<body>
    <div class="container">
        <h1>üîì Obama Decoder</h1>
        <input type="file" id="imageInput" accept="image/*">
        <input type="password" id="passwordInput" placeholder="Password (if file was encrypted)">
        <button onclick="decode()">Decode</button>
        <div id="status" class="status" style="display:none;"></div>
        <canvas id="canvas"></canvas>
        <div id="result">
            <h3>‚úÖ File Extracted!</h3>
            <p><strong>Filename:</strong> <span id="filename"></span></p>
            <p><strong>Size:</strong> <span id="filesize"></span></p>
            <button onclick="downloadFile()" style="background: #4CAF50;">Download File</button>
        </div>
    </div>
    <script>
        let extractedData = null;
        let extractedName = null;

        // Simple XOR decryption with password
        function decryptData(data, password) {
            if (!password) return data;
            const key = new TextEncoder().encode(password);
            const decrypted = new Uint8Array(data.length);
            for (let i = 0; i < data.length; i++) {
                decrypted[i] = data[i] ^ key[i % key.length];
            }
            return decrypted;
        }

        async function decode() {
            const file = document.getElementById('imageInput').files[0];
            const password = document.getElementById('passwordInput').value;
            if (!file) return;

            // Validate file is an image
            if (!file.type.startsWith('image/')) {
                show('‚ùå Please select an image file', '#ffebee');
                return;
            }

            // Validate image file size (50MB limit to prevent memory issues)
            const MAX_IMAGE_SIZE = 50 * 1024 * 1024;
            if (file.size > MAX_IMAGE_SIZE) {
                show('‚ùå Image file too large! Maximum size is 50MB', '#ffebee');
                return;
            }

            try {
                show('Loading image...', '#e3f2fd');
                const img = await loadImage(file);

                // Validate image dimensions
                const MAX_DIMENSION = 8192;
                if (img.width > MAX_DIMENSION || img.height > MAX_DIMENSION) {
                    show('‚ùå Image dimensions too large! Maximum dimension is ' + MAX_DIMENSION + 'px', '#ffebee');
                    return;
                }

                show('Extracting data...', '#e3f2fd');
                const canvas = document.getElementById('canvas');
                canvas.width = img.width;
                canvas.height = img.height;
                // Use specific context settings to prevent color management
                const ctx = canvas.getContext('2d', {
                    willReadFrequently: true,
                    colorSpace: 'srgb',
                    alpha: true
                });
                // Disable image smoothing to preserve exact pixels
                ctx.imageSmoothingEnabled = false;
                ctx.drawImage(img, 0, 0);
                const imgData = ctx.getImageData(0, 0, img.width, img.height);
                const pixels = imgData.data;

                console.log('Image dimensions:', img.width, 'x', img.height);
                console.log('First 10 pixel values:', Array.from(pixels.slice(0, 10)));
                
                // Extract length (first 32 bits = 4 bytes)
                let length = 0;
                for (let i = 0; i < 32; i++) {
                    const pixelIndex = Math.floor(i / 3);
                    const channel = i % 3;
                    const pixelPos = pixelIndex * 4 + channel;
                    const bit = pixels[pixelPos] & 1;
                    length = (length << 1) | bit;
                }
                
                console.log('Extracted length:', length, 'bytes');

                if (length <= 0 || length > 10 * 1024 * 1024) {
                    throw new Error('Invalid data length: ' + length + ' bytes. This image may not contain encoded data, or it was corrupted during download. Try: 1) Re-encoding the file, 2) Right-click "Save image as..." instead of using download button, 3) Use a different browser.');
                }
                
                // Extract data
                const extracted = new Uint8Array(length);
                let bitPos = 32; // Skip the length bytes
                
                for (let i = 0; i < length; i++) {
                    let byte = 0;
                    for (let bit = 7; bit >= 0; bit--) {
                        const pixelIndex = Math.floor(bitPos / 3);
                        const channel = bitPos % 3;
                        const pixelPos = pixelIndex * 4 + channel;
                        const bitValue = pixels[pixelPos] & 1;
                        byte = (byte << 1) | bitValue;
                        bitPos++;
                    }
                    extracted[i] = byte;
                }
                
                console.log('Extracted', extracted.length, 'bytes');

                // Decrypt if password provided
                let toDecompress = extracted;
                if (password) {
                    show('Decrypting...', '#e3f2fd');
                    toDecompress = decryptData(extracted, password);
                }

                show('Decompressing...', '#e3f2fd');
                let decompressed;
                try {
                    decompressed = pako.inflate(toDecompress);
                } catch (e) {
                    console.error('Decompression error:', e);
                    if (password) {
                        throw new Error('Decompression failed. Wrong password, or image was corrupted. Try: 1) Check password, 2) Re-download the image using "Save image as..." (right-click), 3) Re-encode with a different browser.');
                    } else {
                        throw new Error('Decompression failed. File may be encrypted (try entering password), or the image was corrupted during download. Try: 1) Right-click "Save image as..." instead of using download button, 2) Use a different browser.');
                    }
                }

                // Parse metadata
                let metaEnd = 0;
                for (let i = 0; i < decompressed.length; i++) {
                    if (decompressed[i] === 0) {
                        metaEnd = i;
                        break;
                    }
                }

                const metaStr = new TextDecoder().decode(decompressed.slice(0, metaEnd));
                const meta = JSON.parse(metaStr);
                const fileData = decompressed.slice(metaEnd + 1);

                // Check if file was encrypted and warn if no password was provided
                if (meta.encrypted && !password) {
                    show('‚ö†Ô∏è Warning: File was encrypted but no password provided. Data may be corrupted.', '#fff3cd');
                }
                
                extractedData = fileData;
                extractedName = meta.name;
                
                document.getElementById('filename').textContent = meta.name;
                document.getElementById('filesize').textContent = formatBytes(meta.size);
                document.getElementById('result').style.display = 'block';
                show('‚úÖ Success!', '#e8f5e9');
                
            } catch (e) {
                show('Error: ' + e.message, '#ffebee');
                console.error(e);
            }
        }
        
        // Use createImageBitmap() to avoid browser re-encoding via data URLs
        async function loadImage(file) {
            return await createImageBitmap(file);
        }
        
        function downloadFile() {
            if (!extractedData) return;
            const blob = new Blob([extractedData]);
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = extractedName;
            a.click();
            URL.revokeObjectURL(url);
            show('Downloaded!', '#e8f5e9');
        }
        
        function show(msg, color) {
            const s = document.getElementById('status');
            s.textContent = msg;
            s.style.display = 'block';
            s.style.background = color;
        }
        
        function formatBytes(bytes) {
            const k = 1024;
            const sizes = ['Bytes', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return Math.round(bytes / Math.pow(k, i) * 100) / 100 + ' ' + sizes[i];
        }
    </script>
</body>
</html>